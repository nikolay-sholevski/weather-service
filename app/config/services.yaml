# This file is the entry point to configure your own services.
# Files in the packages/ subdirectory configure your dependencies.

# Put parameters here that don't need to change on each machine where the app is deployed
# https://symfony.com/doc/current/best_practices.html#use-parameters-for-application-configuration
parameters:

services:
    # Default configuration for services
    _defaults:
        autowire: true
        autoconfigure: true
        public: false

    App\:
        resource: '../src/'
        exclude:
            - '../src/Kernel.php'

    # Make sure all Infra controllers are registered as services
    App\Infrastructure\Symfony\Controllers\:
        resource: '../src/Infrastructure/Symfony/Controllers/'
        tags: ['controller.service_arguments']

    # Console command for fetching weather 
    App\Infrastructure\Symfony\Command\:
        resource: '../src/Infrastructure/Symfony/Command/*'
        tags: ['console.command']
    
    # Doctrine Adapter
    App\Infrastructure\Persistence\Doctrine\Repository\WeatherHistoryDoctrineAdapter:
        arguments:
            $connection: '@doctrine.dbal.default_connection'
        tags: []

    # Redis client
    redis:
        class: Redis
        calls:
            - method: connect
              arguments:
                  - '%env(REDIS_HOST)%'
                  - '%env(int:REDIS_PORT)%'

    # Domain service
    App\Domain\Services\TrendCalculatorInterface:
        class: App\Domain\Services\SimpleTrendCalculator

    # Outbound ports â†’ concrete adapters
    App\Application\Ports\WeatherHistoryPortInterface:
        class: App\Infrastructure\Persistence\Doctrine\Repository\WeatherHistoryDoctrineAdapter

    # Fake Weather Provider for tests
    App\Infrastructure\Http\Weather\FakeCurrentWeatherProvider:
        public: true

    # Concrete weather provider with apiKey wired
    App\Infrastructure\Http\Weather\OpenWeatherCurrentWeatherProvider:
        arguments:
            $apiKey: '%env(OPENWEATHER_API_KEY)%'

    # Interface aliased to the configured concrete service
    App\Application\Ports\CurrentWeatherProviderInterface:
        #alias: App\Infrastructure\Http\Weather\OpenWeatherCurrentWeatherProvider
        alias: App\Infrastructure\Http\Weather\FakeCurrentWeatherProvider

    # Real use-case implementation
    App\Application\Services\GetCityWeatherService:
        arguments:
            $currentWeatherProvider: '@App\Application\Ports\CurrentWeatherProviderInterface'
            $weatherHistoryPort: '@App\Application\Ports\WeatherHistoryPortInterface'
            $trendCalculator: '@App\Domain\Services\TrendCalculatorInterface'

    # Cache decorator
    App\Infrastructure\Cache\CachedGetCityWeatherService:
        decorates: App\Application\Services\GetCityWeatherService
        arguments:
            $inner: '@App\Infrastructure\Cache\CachedGetCityWeatherService.inner'
            $redis: '@redis'
            $ttlSeconds: '%env(int:WEATHER_CACHE_TTL_SECONDS)%'

    # Bind interface for controllers
    App\Application\Services\GetCityWeatherServiceInterface:
        alias: App\Infrastructure\Cache\CachedGetCityWeatherService



